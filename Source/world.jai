World :: struct {
    loaded_from_directory : string;

    #insert -> string {
        builder : StringBuilder;

        for type_id : 1..Entity_Types.count - 1 {
            Appendln(*builder, "%1_storage : EntityStorage(%1);", Entity_Types[type_id]);
        }

        for type_id : 1..Component_Types.count - 1 {
            Appendln(*builder, "%1_storage : ComponentStorage(%1);", Component_Types[type_id]);
        }

        return StringBuilderBuild(*builder);
    }

    entities_by_name : HashMap(string, *Entity);
    entities_by_guid : HashMap(
        EntityGUID, *Entity,
        hash_func = HashEntityGUID,
        comp_func = (a, b) => a == b
    );

    entities_killed_this_frame : [..]EntityIndex;

    skybox : *Asset(EnvironmentMap); @Serialize(1)
    skybox_light_intensity := 1.0; @Serialize(2) @FloatRange(0,10) @Step(0.01)
}

DestroyWorld :: (using world : *World) {
    FreeEntity :: (world : *World, using entity : *Entity) {
        Free(name.data ,, world.entities_by_name.allocator);
        ArrayFree(*children);
    }

    DerefAsset(*skybox);

    Free(loaded_from_directory.data);

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Entity_Types.count - 1 {
            type := Entity_Types[i];

            Appendln(*builder, "for * %_storage {", type);
            Appendln(*builder, "    #if #exists(%1.OnDespawn) {", type);
            Appendln(*builder, "        it.parent = Null_Entity_GUID;");
            Appendln(*builder, "        ArrayClear(*it.children);");
            Appendln(*builder, "        it.OnDespawn(world, it);");
            Appendln(*builder, "    }");
            Appendln(*builder, "    UnreferenceAllAssets(it);");
            Appendln(*builder, "    HashMapRemove(*world.entities_by_guid, it.guid);");
            Appendln(*builder, "    if it.name {");
            Appendln(*builder, "        HashMapRemove(*world.entities_by_name, it.name);");
            Appendln(*builder, "    }");
            Appendln(*builder, "    FreeEntity(world, it);");
            Appendln(*builder, "    PagedArrayFreeSlot(*%_storage, GetSlotInfo(it.index));", type);
            Appendln(*builder, "}\n");

        }

        for i : 1..Entity_Types.count - 1 {
            Appendln(*builder, "PagedArrayReset(*%_storage);", Entity_Types[i]);
        }

        for i : 1..Component_Types.count - 1 {
            type := Component_Types[i];

            Appendln(*builder, "if %_storage.count > 0 {", type);
            Appendln(*builder, "    LogWarning(\"When destroying world, component storage %1 has \% components that were not destroyed\", %1_storage.count);", type);
            Appendln(*builder, "    #if #exists(%.OnDestroy) {", type);
            Appendln(*builder, "        for * %_storage {", type);
            Appendln(*builder, "            %.OnDestroy(world, it);", type);
            Appendln(*builder, "        }");
            Appendln(*builder, "    }");
            Appendln(*builder, "}");

            Appendln(*builder, "PagedArrayReset(*%_storage);", type);
        }

        return StringBuilderBuild(*builder);
    }

    HashMapFree(*entities_by_guid);
    HashMapFree(*entities_by_name);
    ArrayFree(*entities_killed_this_frame);

    Initialize(world);
}

CopyWorld :: (dest : *World, src : *World) {
    CopyEntityOver :: (dest_world : *World, src_world : *World, entity : *Entity) -> *Entity {
        // @Hack: we serialize then deserialize the entity to copy it, this is not ideal
        serializer : Serializer;
        serializer.builder.allocator = Temp;

        SerializeEntity(*serializer, entity);

        str := StringBuilderBuild(*serializer.builder ,, Temp);

        new_entity := SpawnEntity(dest_world, GetEntityTypeId(entity.index), name=entity.name, guid=entity.guid);
        cached_name := new_entity.name;

        result := DeserializeEntity(str, new_entity);
        if !result.ok {
            LogError("There were errors when deserializing for duplicating entity:\n%:%: %",
                result.line_index + 1, result.byte_index + 1, result.error_msg);
        }

        UpdateWorldTransform(dest_world, new_entity);

        Free(new_entity.name.data);
        new_entity.name = cached_name;

        return new_entity;
    }

    LogSectionScope(*Log_Entities);

    DestroyWorld(dest);

    for :AllEntities entity : src {
        CopyEntityOver(dest, src, entity);
    }

    // Attach all entities to their parent correctly
    for :AllEntities entity : dest {
        if entity.parent != Null_Entity_GUID {
            parent_id := entity.parent;
            entity.parent = Null_Entity_GUID;

            parent, err := GetEntity(dest, *parent_id);
            if !parent {
                LogError("Entity does not exist %", parent_id);
                continue;
            }

            AttachEntity(dest, entity, parent);
        }
    }
}

// for_expansion
AllEntities :: (world : *World, body : Code, flags : For_Flags) #expand {
    `it : *Entity;
    `it_index : EntityIndex;
    should_break := false;

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Entity_Types.count - 1 {
            if i != 1 {
                Appendln(*builder, "\nif should_break {\n    return;\n}\n");
            }

            Appendln(*builder, "for * entity, index : world.%_storage {", Entity_Types[i]);
            Appendln(*builder, "    it = entity;");
            Appendln(*builder, "    it_index = entity.index;");
            Appendln(*builder, "    #insert(break={should_break=true;break;}) body;");
            Appendln(*builder, "}");
        }

        return StringBuilderBuild(*builder);
    }
}

// for_expansion
AllEntitiesWithCallback :: ($Callback : string, world : *World, body : Code, flags : For_Flags) #expand {
    `it : *Entity;
    `it_index : EntityIndex;
    should_break := false;

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Entity_Types.count - 1 {
            info := cast(*Type_Info_Struct, Entity_Types[i]);

            has_callback := false;
            for info.members {
                if it.name == Callback {
                    has_callback = true;
                    break;
                }
            }

            if !has_callback {
                continue;
            }

            if i != 1 {
                Appendln(*builder, "\nif should_break {\n    return;\n}\n");
            }

            Appendln(*builder, "for * entity, index : world.%_storage {", Entity_Types[i]);
            Appendln(*builder, "    it = entity;");
            Appendln(*builder, "    it_index = entity.index;");
            Appendln(*builder, "    #insert(break={should_break=true;break;}) body;");
            Appendln(*builder, "}");
        }

        return StringBuilderBuild(*builder);
    }
}

// for_expansion
AllVisibleEntities :: (world : *World, body : Code, flags : For_Flags) #expand {
    for :AllEntities `it, `it_index : world {
        if it.flags & .Hidden {
            continue;
        }

        #insert body;
    }
}

// for_expansion
AllComponents :: (world : *World, body : Code, flags : For_Flags) #expand {
    Index :: struct {
        type : Type;
        index : int;
    }

    `it : *Component;
    `it_index : Index;
    should_break := false;

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Component_Types.count - 1 {
            if i != 1 {
                Appendln(*builder, "\nif should_break {\n    return;\n}\n");
            }

            Appendln(*builder, "it_index = .{type=%};", Component_Types[i]);
            Appendln(*builder, "for * component, index : world.%_storage {", Component_Types[i]);
            Appendln(*builder, "    it = component;");
            Appendln(*builder, "    it_index.index += 1;");
            Appendln(*builder, "    #insert(break={should_break=true;break;}) body;");
            Appendln(*builder, "}");
        }

        return StringBuilderBuild(*builder);
    }
}

// for_expansion
AllComponentsWithCallback :: ($Callback : string, world : *World, body : Code, flags : For_Flags) #expand {
    Index :: struct {
        type : Type;
        index : int;
    }

    `it : *Component;
    `it_index : Index;
    should_break := false;

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Component_Types.count - 1 {
            info := cast(*Type_Info_Struct, Component_Types[i]);

            has_callback := false;
            for info.members {
                if it.name == Callback {
                    has_callback = true;
                    break;
                }
            }

            if !has_callback {
                continue;
            }

            if i != 1 {
                Appendln(*builder, "\nif should_break {\n    return;\n}\n");
            }

            Appendln(*builder, "it_index = .{type=%};", Component_Types[i]);
            Appendln(*builder, "for * component, index : world.%_storage {", Component_Types[i]);
            Appendln(*builder, "    it = component;");
            Appendln(*builder, "    it_index.index += 1;");
            Appendln(*builder, "    #insert(break={should_break=true;break;}) body;");
            Appendln(*builder, "}");
        }

        return StringBuilderBuild(*builder);
    }
}

LoadWorldFromDirectory :: (world : *World, directory : string) {
    LogSectionScope(*Log_Entities);

    start_time := Basic.current_time_monotonic();
    loaded_entities := 0;

    DestroyWorld(world);

    world.loaded_from_directory = StringClone(directory);

    DeferNextAssetLoadsForAllCaches();

    defer {
        end_time := Basic.current_time_monotonic();
        total_time_ms := Basic.to_float64_seconds(end_time - start_time) * 1000;

        asset_start_time := Basic.current_time_monotonic();

        LoadPendingAssets();

        asset_end_time := Basic.current_time_monotonic();
        asset_total_time_ms := Basic.to_float64_seconds(asset_end_time - asset_start_time) * 1000;

        LogContentMessage("Loaded world from directory '%' (% entities) in % ms",
            directory, loaded_entities, total_time_ms);
        LogMessage("Loaded assets for scene in % ms", asset_total_time_ms);
    }

    files : []string;

    // No logging please!
    {
        LoggerScope(null, IgnoreLogger);
        files = file_list(directory ,, Temp);
    }

    found_world_file := false;
    for files {
        if path_extension(it) == "world" {
            if found_world_file {
                LogContentError("Found multiple .world files in directory '%'", directory);
                continue;
            }

            found_world_file = true;

            file_contents, file_ok := read_entire_file(it, log_errors=false);
            if !file_ok {
                LogContentError("Could not read file '%'", it);
                continue;
            }

            defer Free(file_contents.data);

            result := DeserializeAny(file_contents, world);
            if !result.ok {
                LogContentError("There were errors when deserializing world settings:\n%:%:%: %",
                    it, result.line_index + 1, result.byte_index + 1, result.error_msg);
            }
        } else if path_extension(it) == "entity" {
            basename := path_basename(it);
            guid_str := string.{0, basename.data};
            for i : 0..basename.count - 1 {
                if basename[i] == #char "_" {
                    break;
                }

                guid_str.count += 1;
            }

            type_str := StringAdvance(basename, guid_str.count + 1);

            guid : EntityGUID;
            guid.high, ok:, guid_str = ParseFixedWidthHexInteger(guid_str, 16, u64);
            if !ok {
                LogContentError("Invalid entity filename '%' (invalid GUID)", it);
                continue;
            }

            guid.low, ok, guid_str = ParseFixedWidthHexInteger(guid_str, 16, u64);
            if !ok || guid_str.count != 0 {
                LogContentError("Invalid entity filename '%' (invalid GUID)", it);
                continue;
            }

            type := void;
            type_id := EntityTypeId.Invalid;
            for i : 1..Entity_Types.count - 1 {
                info_struct := cast(*Type_Info_Struct) Entity_Types[i];
                if info_struct.name == type_str {
                    type = Entity_Types[i];
                    type_id = cast(EntityTypeId) i;
                    break;
                }
            }

            if type == void {
                LogContentError("Invalid entity filename '%' (invalid type name '%')", it, type_str);
                continue;
            }

            file_contents, file_ok := read_entire_file(it, log_errors=false);
            if !file_ok {
                LogContentError("Could not read file '%'", it);
                continue;
            }

            defer Free(file_contents.data);

            entity := SpawnEntity(world, type_id, guid=guid);

            result := DeserializeEntity(file_contents, entity);
            if !result.ok {
                LogContentError("There were errors when deserializing entity:\n%:%:%: %",
                    it, result.line_index + 1, result.byte_index + 1, result.error_msg);
            }

            UpdateWorldTransform(world, entity);

            if entity.name {
                name := entity.name;
                entity.name = "";
                SetEntityName(world, entity, name);
                Free(name.data);
            }

            loaded_entities += 1;
        }
    }

    // Attach all entities to their parent correctly
    for :AllEntities entity : world {
        if entity.parent != Null_Entity_GUID {
            parent_id := entity.parent;
            entity.parent = Null_Entity_GUID;

            parent, err := GetEntity(world, *parent_id);
            if !parent {
                LogError("Entity does not exist %", parent_id);
                continue;
            }

            AttachEntity(world, entity, parent);
        }
    }
}

SaveWorldToDirectory :: (world : *World, output_directory : string) {
    LogSectionScope(*Log_Entities);

    start_time := Basic.current_time_monotonic();

    // No logging please!
    {
        LoggerScope(null, IgnoreLogger);

        files := file_list(output_directory ,, Temp);
        for files {
            if path_extension(it) == "entity" || path_extension(it) == "world" {
                file_delete(it);
            }
        }
    }

    make_directory_if_it_does_not_exist(output_directory, recursive=true);

    saved_entities := 0;

    for :AllEntities world {
        serializer : Serializer;
        serializer.builder.allocator = Temp;

        SerializeEntity(*serializer, it);

        filename := TPrint("%/%_%.entity", output_directory, it.guid, GetEntityType(it.index));
        ok := write_entire_file(filename, *serializer.builder);
        if !ok {
            LogContentError("Could not save entity to file '%'", filename);
        } else {
            saved_entities += 1;
        }
    }

    old_dir := world.loaded_from_directory; // Just in case output_directory.data == world.loaded_from_directory.data
    world.loaded_from_directory = StringClone(output_directory);
    Free(old_dir.data);

    serializer : Serializer;
    serializer.builder.allocator = Temp;

    SerializeAny(*serializer, world);

    world_filename := TPrint("%/%.world", output_directory, path_basename(output_directory));

    ok := write_entire_file(world_filename, *serializer.builder);
    if !ok {
        LogContentError("Could not save world to file '%'", world_filename);
    }

    end_time := Basic.current_time_monotonic();
    total_time_ms := Basic.to_float64_seconds(end_time - start_time) * 1000;

    LogContentMessage("Saved world to directory '%' (% entities) in % ms",
        output_directory, saved_entities, total_time_ms);
}
