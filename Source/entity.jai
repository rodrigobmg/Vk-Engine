// Generated by the metaprogram
#placeholder Entity_Types;
#placeholder EntityTypeId;
#placeholder Component_Types;

Log_Entities :: Log_Section.{name="Entities"};

// Index into Entity_Types array, index Invalid maps to void

#insert -> string {
    builder : StringBuilder;

    Appendln(*builder, "EntityTypeId :: enum u8 {");
    Appendln(*builder, "    Invalid :: 0;");

    for i : 1..Entity_Types.count - 1 {
        Appendln(*builder, "    % :: %;", Entity_Types[i], i);
    }

    Appendln(*builder, "}");

    return StringBuilderBuild(*builder);
};

#assert Entity_Types.count <= 256; // The type id must fit in a u8

Detect_Entity_Recursive_Attachment :: true;

Entities_Per_Page :: 20;
Components_Per_Page :: 20;

EntityStorage :: #bake_arguments PagedArray(Page_Size=Entities_Per_Page);
ComponentStorage :: #bake_arguments PagedArray(Page_Size=Components_Per_Page);

World :: struct {
    loaded_from_directory : string;

    #insert -> string {
        builder : StringBuilder;

        for type_id : 1..Entity_Types.count - 1 {
            Appendln(*builder, "%1_storage : EntityStorage(%1);", Entity_Types[type_id]);
        }

        for type_id : 1..Component_Types.count - 1 {
            Appendln(*builder, "%1_storage : ComponentStorage(%1);", Component_Types[type_id]);
        }

        return StringBuilderBuild(*builder);
    }

    entities_by_name : HashMap(string, *Entity);
    entities_by_guid : HashMap(
        EntityGUID, *Entity,
        hash_func = HashEntityGUID,
        comp_func = (a, b) => a == b
    );

    entities_killed_this_frame : [..]EntityIndex;

    skybox : *Asset(EnvironmentMap); @Serialize(1)
    skybox_light_intensity := 1.0; @Serialize(2) @FloatRange(0,10) @Step(0.01)
}
#placeholder Component_Types;

ComponentGUID :: struct {
    low, high : u64;
}

Component :: struct {
    index : PagedArraySlotInfo;
    entity : EntityGUID;
}

CreateComponent :: (world : *World, storage : *ComponentStorage, entity : EntityGUID) -> *storage.T {
    component, index := PagedArrayFindSlot(storage);
    component.entity = entity;
    component.index = index;

    #if exists(storage.T.OnCreate) {
        component.OnCreate(world, component);
    }
}

DestroyComponent :: (world : *World, storage : *ComponentStorage, component : *storage.T) {
    #if exists(storage.T.OnDestroy) {
        component.OnDestroy(world, component);
    }

    PagedArrayFreeSlot(storage, component.index);
}

CreateComponent :: (world : *World, $T : Type, entity : EntityGUID) -> *T {
    storage := #insert TPrint("*world.%_storage;", T);
    return CreateComponent(world, storage, entity);
}

DestroyComponent :: (world : *World, component : *$T) {
    storage := #insert TPrint("*world.%_storage;", T);
    return DestroyComponent(world, storage, component);
}

EntityFlags :: enum_flags {
    Hidden;
}

Entity :: struct {
    #as guid : EntityGUID; @Serialize(1) @HideInInspector
    index : EntityIndex;
    flags : EntityFlags; @Serialize(7)

    name : string; @Serialize(2) @HideInInspector

    local_position : Vec3f; @Serialize(3)
    local_rotation : Quatf; @Serialize(4)
    local_scale : Vec3f = .{1,1,1}; @Serialize(5)

    world_transform : Mat4f;
    parent : EntityGUID; @Serialize(6)
    children : [..]EntityIndex;
}

EmptyEntity :: struct {
    #as using _ : Entity; @Serialize(1) @InspectorNoTree
} @Entity

// EntityIndex is guaranteed to be unique for all currently existing entities
// It is a compressed version of PagedArraySlotInfo with an additional id
// for the entity type.
// Layout: [8 bit type_id][24 bit version][24 bit page_index][8 bit slot_index]

Entity_Index_Type_Id_Bits   :: 8;
Entity_Index_Type_Id_Offset :: Entity_Index_Version_Offset + Entity_Index_Version_Bits;

Entity_Index_Version_Bits   :: 24;
Entity_Index_Version_Offset :: Entity_Index_Page_Index_Offset + Entity_Index_Page_Index_Bits;

Entity_Index_Page_Index_Bits   :: 24;
Entity_Index_Page_Index_Offset :: Entity_Index_Slot_Index_Offset + Entity_Index_Slot_Index_Bits;

Entity_Index_Slot_Index_Bits   :: 8;
Entity_Index_Slot_Index_Offset :: 0;

#assert Entity_Index_Type_Id_Offset + Entity_Index_Type_Id_Bits <= size_of(EntityIndex) * 8;

EntityIndex :: #type, distinct u64;

Null_Entity_GUID :: EntityGUID.{};

EntityGUID :: struct {
    low, high : u64;
}

operator == :: inline (a : EntityGUID, b : EntityGUID) -> bool {
    return a.low == b.low && a.high == b.high;
}

HashEntityGUID :: inline (guid : EntityGUID) -> u64 {
    #import "Hash";

    h := fnv1a_hash(guid.low);
    h = fnv1a_hash(guid.high, h);

    return h;
}

g_entity_guid_random_state_low : Random_State;
g_entity_guid_random_state_high : Random_State;

GenerateEntityGUID :: () -> EntityGUID {
    #import "Random";

    if g_entity_guid_random_state_low.low == 0 && g_entity_guid_random_state_low.high == 0 {
        seed := Basic.current_time_monotonic();
        random_seed(*g_entity_guid_random_state_low, Random_State.{xx seed.low, xx seed.high});
        random_seed(*g_entity_guid_random_state_high, Random_State.{xx seed.high, xx seed.low});
    }

    return .{
        random_get(*g_entity_guid_random_state_low),
        random_get(*g_entity_guid_random_state_high),
    };
}

CompareEntityIndex :: inline (a : EntityIndex, b : EntityIndex) -> int {
    if a < b {
        return -1;
    }
    if a > b {
        return 1;
    }
    return 0;
}

IsInEntityTypesArray :: (type : Type) -> bool {
    for i : 1..Entity_Types.count - 1 {
        if Entity_Types[i] == type {
            return true;
        }
    }

    return false;
}

GetEntityTypeId :: (type : Type) -> EntityTypeId {
    for Entity_Types {
        if it == type {
            return cast(EntityTypeId, it_index);
        }
    }

    return .Invalid;
}

GetEntityTypeId :: inline (index : EntityIndex) -> EntityTypeId {
    type_id := cast(u8, index >> Entity_Index_Type_Id_Offset);

    if type_id >= Entity_Types.count {
        return .Invalid;
    }

    return cast(EntityTypeId, type_id);
}

GetEntityType :: inline (index : EntityIndex) -> Type {
    return GetEntityType(GetEntityTypeId(index));
}

GetEntityType :: inline (type_id : EntityTypeId) -> Type {
    return Entity_Types[type_id];
}

MakeEntityIndex :: inline (type_id : EntityTypeId, using slot_info : PagedArraySlotInfo) -> EntityIndex {
    Assert(version == (version & 0xffffff), "Version number is too big");
    Assert(page_index == (page_index & 0xffffff), "Page index is too big");
    Assert(slot_index == (slot_index & 0xff), "Slot index is too big");

    result :=
          (cast(u64, type_id)    << Entity_Index_Type_Id_Offset)
        | (cast(u64, version)    << Entity_Index_Version_Offset)
        | (cast(u64, page_index) << Entity_Index_Page_Index_Offset)
        | (cast(u64, slot_index) << Entity_Index_Slot_Index_Offset);

    return cast(EntityIndex, result);
}

GetSlotInfo :: inline (index : EntityIndex) -> PagedArraySlotInfo {
    return .{
        cast(u32, (index >> Entity_Index_Version_Offset)    & 0xffffff),
        cast(s32, (index >> Entity_Index_Page_Index_Offset) & 0xffffff),
        cast(s32, (index >> Entity_Index_Slot_Index_Offset) & 0xff)
    };
}

EntityIsInHierarchy :: (world : *World, entity : *Entity, of : *Entity) -> bool {
    if !entity {
        return false;
    }

    if entity == of {
        return true;
    }

    if of.children.count == 0 {
        return false;
    }

    for of.children {
        child := GetEntity(world, it);
        if entity == child {
            return true;
        }
    }

    for of.children {
        child := GetEntity(world, it);

        if EntityIsInHierarchy(world, entity, child) {
            return true;
        }
    }

    return false;
}

TryDowncast :: inline (entity : *Entity, $T : Type) -> *T
#modify { return IsInEntityTypesArray(T); } {
    if !entity {
        return null;
    }

    if GetEntityTypeId(entity.index) != #run GetEntityTypeId(T) {
        return null;
    }

    return cast(*T, entity);
}

Downcast :: inline (entity : *Entity, $T : Type) -> *T
#modify { return IsInEntityTypesArray(T); } {
    if !entity {
        return null;
    }

    if GetEntityTypeId(entity.index) != #run GetEntityTypeId(T) {
        LogError(
            "Entity downcast failed: type % does not match entity type id %",
            T, GetEntityTypeId(entity.index)
        );

        return null;
    }

    return cast(*T, entity);
}

SetEntityName :: inline (using world : *World, entity : *Entity, new_name : string) -> set_same_name : bool {
    LogSectionScope(*Log_Entities);

    SeparatePostfixNumber :: (str : string) -> postfix : int, name_without_postfix : string {
        dot_index := find_index_from_right(str, #char ".");
        if dot_index == -1 || dot_index == str.count - 1 {
            return -1, str;
        }

        for i : dot_index + 1..str.count - 1 {
            if !Basic.is_digit(str[i]) {
                return -1, str;
            }
        }

        str_without_postfix := str;
        str_without_postfix.count = dot_index;
        postfix_str := StringAdvance(str, dot_index + 1);
        postfix := Basic.string_to_int(postfix_str);

        return postfix, str_without_postfix;
    }

    if entity.name {
        HashMapRemove(*entities_by_name, entity.name);
        Free(entity.name.data ,, entities_by_name.allocator);
        entity.name = "";
    }

    if !new_name {
        return true;
    }

    number_postfix := -1;

    // Try to prevent .0.0.0.0 postfix by parsing the name and trimming the .NUMBER at the end
    first_number_postfix, name_without_postfix := SeparatePostfixNumber(new_name);
    while true {
        if number_postfix == -1 {
            entity.name = StringClone(new_name ,, entities_by_name.allocator);
        } else {
            entity.name = SPrint("%.%", name_without_postfix, number_postfix ,, entities_by_name.allocator);
        }

        entity_ptr, already_exists := HashMapInsert(*entities_by_name, entity.name);
        if already_exists {
            if number_postfix == -1 {
                number_postfix = first_number_postfix + 1;
            } else {
                number_postfix += 1;
            }

            // LogError("Entity with name '%' already exists", entity.name);

            Free(entity.name.data ,, entities_by_name.allocator);
            entity.name = "";
        } else {
            entity_ptr.* = entity;
            break;
        }
    }

    return number_postfix == -1;
}

GetEntityError :: enum {
    Ok;
    NullEntity;
    InvalidEntityIndex;
    EntityKilled;
    EntityKilledOrNeverSpawned;
    DowncastFailed;
}

GetEntityByName :: inline (using world : *World, name : string) -> *Entity {
    return HashMapGet(*entities_by_name, name, fallback = null);
}

GetEntityByName :: inline (using world : *World, name : string, $T : Type) -> *T, GetEntityError
#modify { return IsInEntityTypesArray(T); } {
    entity := HashMapGet(*entities_by_name, name, fallback = null);
    if !entity {
        return null, .NullEntity;
    }

    typed_entity := TryDowncast(entity, T);
    if !typed_entity {
        return null, .DowncastFailed;
    }

    return typed_entity, .Ok;
}

GetEntity :: (using world : *World, guid : EntityGUID, $T : Type) -> *T, GetEntityError
#modify { return IsInEntityTypesArray(T); } {
    entity, err := GetEntity(world, guid);
    if !entity {
        return null, err;
    }

    typed_entity := TryDowncast(entity, T);
    if !typed_entity {
        return null, .DowncastFailed;
    }

    return typed_entity, .Ok;
}

GetEntity :: (using world : *World, guid : EntityGUID) -> *Entity, GetEntityError {
    if guid == Null_Entity_GUID {
        return null, .NullEntity;
    }

    entity, err := HashMapGet(*entities_by_guid, guid);
    if !entity {
        return null, .EntityKilledOrNeverSpawned;
    }

    return entity, .Ok;
}

GetEntity :: (using world : *World, index : EntityIndex, $T : Type) -> *T, GetEntityError
#modify { return IsInEntityTypesArray(T); } {
    entity, err := GetEntity(world, index);
    if !entity {
        return null, err;
    }

    typed_entity := TryDowncast(entity, T);
    if !typed_entity {
        return null, .DowncastFailed;
    }

    return typed_entity, .Ok;
}

GetEntity :: (using world : *World, index : EntityIndex) -> *Entity, GetEntityError {
    LogSectionScope(*Log_Entities);

    if index == 0 {
        return null, .NullEntity;
    }

    type_id := GetEntityTypeId(index);
    slot_info := GetSlotInfo(index);

    #insert -> string {
        builder : StringBuilder;

        Appendln(*builder, "if #complete type_id == {");
        Appendln(*builder, "case .Invalid; LogError(\"Requesting entity with invalid type id(\%)\", type_id); return null, .InvalidEntityIndex;");

        for i : 1..Entity_Types.count - 1
        {
            it := Entity_Types[i];
            Appendln(*builder, "case .%;", it);
            Appendln(*builder, "    valid, corrupt, not_occupied, version_mismatch := PagedArrayIsSlotValid(*%_storage, slot_info);", it);
            Appendln(*builder, "    if not_occupied || version_mismatch {");
            Appendln(*builder, "        return null, .EntityKilled;");
            Appendln(*builder, "    }");
            Appendln(*builder, "    if !valid {");
            Appendln(*builder, "        return null, .InvalidEntityIndex;");
            Appendln(*builder, "    }");
            Appendln(*builder, "    return PagedArrayGetItem(*%_storage, slot_info), .Ok;", it);
        }

        Appendln(*builder, "}");

        return StringBuilderBuild(*builder);
    }

    return null, .InvalidEntityIndex;
}

CallEntityCallback :: (world : *World, entity : *Entity, $Callback : string) {
    #insert -> string {
        builder : StringBuilder;

        Appendln(*builder, "if GetEntityTypeId(entity.index) == {");
        for i : 1..Entity_Types.count - 1 {
            type := Entity_Types[i];
            Appendln(*builder, "case .%1; #if #exists(%1.%2) { %1.%2(world, xx entity); }", type, Callback);
        }
        Appendln(*builder, "}");

        return StringBuilderBuild(*builder);
    }
}

CallEntityCallback :: inline (world : *World, entity : *$T, $Callback : string)
#modify { return IsInEntityTypesArray(T); } {
    #insert #run TPrint("#if #exists(T.%1) { T.%1(world, entity); }", Callback);
}

AttachEntity :: (using world : *World, entity : *Entity, to : *Entity, keep_same_world_transform := false) {
    LogSectionScope(*Log_Entities);

    Assert(entity != null);
    Assert(to != null);

    if entity == to {
        LogError("Trying to attach entity to itself");
        return;
    }

    // Detect entity attaching itself to one of its descendants
    #if Detect_Entity_Recursive_Attachment {
        if EntityIsInHierarchy(world, to, entity) {
            LogError("Trying to recursively attach entity to one of its descendants");
            return;
        }
    }

    if entity.parent != Null_Entity_GUID {
        DetachEntity(world, entity);
    }

    ArrayPush(*to.children, entity.index);

    entity.parent = to.guid;

    if keep_same_world_transform {
        local_transform := Inverse(to.world_transform) * entity.world_transform;

        entity.local_position = TranslationVector(local_transform);
        entity.local_rotation = QuatfFromMatrix(local_transform);

        // Extracting scale from a matrix does not give good results, walk the hierarchy instead
        // @Todo: orientations may not be the same between a parent and its child, so X axis scale of parent
        // may not be X axis scale of child. Use GetScaleOnAxis like we do in EntityGizmo procedure.
        parent_for_scale := to;
        while parent_for_scale {
            entity.local_scale = InvScale(entity.local_scale, parent_for_scale.local_scale);
            parent_for_scale = GetEntity(world, parent_for_scale.parent);
        }
    }

    UpdateWorldTransform(world, entity);
    CallEntityCallback(world, entity, "OnAttach");

    LogMessage("Attached entity % to %", entity.guid, to.guid, flags=.VERBOSE_ONLY);
}

DetachEntity :: (using world : *World, entity : *Entity, keep_same_world_transform := false) {
    LogSectionScope(*Log_Entities);

    if entity.parent == Null_Entity_GUID {
        return;
    }

    CallEntityCallback(world, entity, "OnDetach");

    parent := GetEntity(world, *entity.parent);
    Assert(parent != null);

    child_index := ArrayFindFirst(parent.children, entity.index);
    Assert(child_index != -1);

    ArrayRemove(*parent.children, child_index);

    entity.parent = .{};

    if keep_same_world_transform {
        entity.local_position = TranslationVector(entity.world_transform);
        entity.local_rotation = QuatfFromMatrix(entity.world_transform);

        // Extracting scale from a matrix does not give good results, walk the hierarchy instead
        parent_for_scale := parent;
        while parent_for_scale {
            entity.local_scale = Scale(entity.local_scale, parent_for_scale.local_scale);
            parent_for_scale = GetEntity(world, parent_for_scale.parent);
        }
    }

    UpdateWorldTransform(world, entity);

    LogMessage("Detached entity % from %", entity.guid, parent.guid, flags=.VERBOSE_ONLY);
}

UpdateWorldTransform :: (world : *World, entity : *Entity, update_children := true) {
    parent := ifx entity.parent != Null_Entity_GUID then GetEntity(world, *entity.parent);

    local_transform := Mat4fTransformSRT(entity.local_position, entity.local_rotation, entity.local_scale);

    if parent {
        entity.world_transform = parent.world_transform * local_transform;

        // Remove skewing from world transform
        Q, S := PolarDecompose(entity.world_transform);
        S2 := Mat4f.{r0c0=S.r0c0, r1c1=S.r1c1, r2c2=S.r2c2, r3c3=1};

        T := Mat4fTranslate(TranslationVector(entity.world_transform));

        entity.world_transform = T * ToMat4f(Q) * S2;
    } else {
        entity.world_transform = local_transform;
    }

    if update_children {
        for entity.children {
            child := GetEntity(world, it);
            Assert(child != null);

            UpdateWorldTransform(world, child);
        }
    }
}

SpawnEntity :: (using world : *World, $T : Type, name := "", guid := Null_Entity_GUID) -> *T
#modify { return IsInEntityTypesArray(T); } {
    entity := SpawnEntity(world, #run GetEntityTypeId(T), name, guid);

    return cast(*T, entity);
}

SpawnEntity :: (using world : *World, type : EntityTypeId, name := "", guid := Null_Entity_GUID) -> *Entity {
    LogSectionScope(*Log_Entities);

    if type == .Invalid {
        return null;
    }

    entity : *Entity;
    slot_info : PagedArraySlotInfo;
    #insert -> string {
        builder : StringBuilder;

        Appendln(*builder, "if type == {");

        for i : 1..Entity_Types.count - 1 {
            Appendln(*builder, "case .%;", Entity_Types[i]);
            Appendln(*builder, "    entity, slot_info = PagedArrayFindSlot(*%_storage);", Entity_Types[i]);
            Appendln(*builder, "    CallEntityCallback(world, cast(*%, entity), \"OnSpawn\");", Entity_Types[i]);
        }

        Appendln(*builder, "}");

        return StringBuilderBuild(*builder);
    }

    entity.index = MakeEntityIndex(type, slot_info);

    if guid.low || guid.high {
        entity.guid = guid;
    } else {
        entity.guid = GenerateEntityGUID();
    }

    entity_ptr, already_exists := HashMapInsert(*entities_by_guid, entity.guid);
    if already_exists {
        LogError("Entity with GUID % already exists", entity.guid);
    } else {
        entity_ptr.* = entity;
    }

    if name {
        SetEntityName(world, entity, name);
    }

    if name {
        LogMessage("Spawned entity % (%, %)",
            name, type, entity.guid,
            flags=.VERBOSE_ONLY
        );
    } else {
        LogMessage("Spawned entity (%, %)",
            type, entity.guid,
            flags=.VERBOSE_ONLY
        );
    }

    return entity;
}

SpawnAndDeserializeEntity :: (using world : *World, text : string, type_id : EntityTypeId, name := "", guid := Null_Entity_GUID) -> *Entity {
    entity := SpawnEntity(world, type_id, guid=guid, name=name);
    cached_name := entity.name;

    result := DeserializeEntity(text, entity);
    if !result.ok {
        LogContentError("There were errors when deserializing entity:\n%_%:%:%: %",
            type_id, guid, result.line_index + 1, result.byte_index + 1, result.error_msg);
    }

    UpdateWorldTransform(world, entity);

    if cached_name {
        Assert(cached_name == entity.name);
        Free(entity.name.data);
        entity.name = cached_name;
    } else if entity.name {
        name := entity.name;
        entity.name = "";
        SetEntityName(world, entity, name);
        Free(name.data);
    }

    if entity.parent != Null_Entity_GUID {
        parent, err := GetEntity(world, *entity.parent);
        if parent {
            // AttachEntity detaches from previous parent, so clear entity.parent beforehand
            entity.parent = .{};
            AttachEntity(world, entity, parent);
        } else {
            LogError("In SpawnAndDeserializeEntity, when trying to attach entity, GetEntity failed for parent % (%)", entity.parent, err);
            entity.parent = .{};
        }
    }

    return entity;
}

SerializeEntity :: inline (serializer : *Serializer, entity : *Entity) {
    any : Any = ---;
    any.type = cast(*Type_Info, GetEntityType(GetEntityTypeId(entity.index)));
    any.value_pointer = entity;

    SerializeAny(serializer, any);
}

DeserializeEntity :: inline (text : string, entity : *Entity) -> DeserializeResult {
    any : Any = ---;
    any.type = cast(*Type_Info, GetEntityType(GetEntityTypeId(entity.index)));
    any.value_pointer = entity;

    cached_guid := entity.guid;
    cached_index := entity.index;
    result := DeserializeAny(text, any);
    entity.guid = cached_guid;
    entity.index = cached_index;

    return result;
}

KillEntity :: (using world : *World, guid : EntityGUID) {
    LogSectionScope(*Log_Entities);

    entity := GetEntity(world, guid);
    if entity == null {
        LogError("Killing entity with GUID % but it does not exist", guid);
        return;
    }

    for entities_killed_this_frame {
        if it == entity.index {
            return;
        }
    }

    ArrayPush(*entities_killed_this_frame, entity.index);
}

KillEntity :: (using world : *World, index : EntityIndex) {
    LogSectionScope(*Log_Entities);

    if GetEntity(world, index) == null {
        LogError("Killing entity with index % but it does not exist", index);
        return;
    }

    for entities_killed_this_frame {
        if it == index {
            return;
        }
    }

    ArrayPush(*entities_killed_this_frame, index);
}

DestroyKilledEntities :: (using world : *World) {
    DestroyEntity :: (using world : *World, index : EntityIndex) {
        entity := GetEntity(world, index);
        Assert(entity != null);

        type_id := GetEntityTypeId(index);

        if entity.parent != Null_Entity_GUID {
            DetachEntity(world, entity, keep_same_world_transform=true);
        }

        while entity.children.count > 0 {
            child := GetEntity(world, entity.children[0]);
            if child {
                DetachEntity(world, child, keep_same_world_transform=true);
            }
        }

        CallEntityCallback(world, entity, "OnDespawn");

        ArrayFree(*entity.children);

        if entity.name {
            Free(entity.name.data ,, entities_by_name.allocator);
            HashMapRemove(*entities_by_name, entity.name);
        }

        HashMapRemove(*entities_by_guid, entity.guid);

        slot_info := GetSlotInfo(entity.index);

        #insert -> string {
            builder : StringBuilder;

            Appendln(*builder, "if type_id == {");

            for i : 1..Entity_Types.count - 1 {
                Appendln(*builder, "case .%;", Entity_Types[i]);
                Appendln(*builder, "    UnreferenceAllAssets(cast(*%, entity));", Entity_Types[i]);
                Appendln(*builder, "    PagedArrayFreeSlot(*%_storage, slot_info);", Entity_Types[i]);
            }

            Appendln(*builder, "}");

            return StringBuilderBuild(*builder);
        }
    }

    LogSectionScope(*Log_Entities);

    // Sorted by memory proximity and type
    QuickSort(entities_killed_this_frame, CompareEntityIndex);

    for index : entities_killed_this_frame {
        DestroyEntity(world, index);
    }

    ArrayClear(*entities_killed_this_frame);
}

DestroyWorld :: (using world : *World) {
    FreeEntity :: (world : *World, using entity : *Entity) {
        Free(name.data ,, world.entities_by_name.allocator);
        ArrayFree(*children);
    }

    DerefAsset(*skybox);

    Free(loaded_from_directory.data);

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Entity_Types.count - 1 {
            type := Entity_Types[i];

            Appendln(*builder, "for * %_storage {", type);
            Appendln(*builder, "    #if #exists(%1.OnDespawn) {", type);
            Appendln(*builder, "        it.parent = Null_Entity_GUID;");
            Appendln(*builder, "        ArrayClear(*it.children);");
            Appendln(*builder, "        it.OnDespawn(world, it);");
            Appendln(*builder, "    }");
            Appendln(*builder, "    UnreferenceAllAssets(it);");
            Appendln(*builder, "    HashMapRemove(*world.entities_by_guid, it.guid);");
            Appendln(*builder, "    if it.name {");
            Appendln(*builder, "        HashMapRemove(*world.entities_by_name, it.name);");
            Appendln(*builder, "    }");
            Appendln(*builder, "    FreeEntity(world, it);");
            Appendln(*builder, "    PagedArrayFreeSlot(*%_storage, GetSlotInfo(it.index));", type);
            Appendln(*builder, "}\n");
        }

        return StringBuilderBuild(*builder);
    }

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Entity_Types.count - 1 {
            Appendln(*builder, "PagedArrayReset(*%_storage);", Entity_Types[i]);
        }

        return StringBuilderBuild(*builder);
    }

    HashMapFree(*entities_by_guid);
    HashMapFree(*entities_by_name);
    ArrayFree(*entities_killed_this_frame);

    Initialize(world);
}

CopyWorld :: (dest : *World, src : *World) {
    CopyEntityOver :: (dest_world : *World, src_world : *World, entity : *Entity) -> *Entity {
        // @Hack: we serialize then deserialize the entity to copy it, this is not ideal
        serializer : Serializer;
        serializer.builder.allocator = Temp;

        SerializeEntity(*serializer, entity);

        str := StringBuilderBuild(*serializer.builder ,, Temp);

        new_entity := SpawnEntity(dest_world, GetEntityTypeId(entity.index), name=entity.name, guid=entity.guid);
        cached_name := new_entity.name;

        result := DeserializeEntity(str, new_entity);
        if !result.ok {
            LogError("There were errors when deserializing for duplicating entity:\n%:%: %",
                result.line_index + 1, result.byte_index + 1, result.error_msg);
        }

        UpdateWorldTransform(dest_world, new_entity);

        Free(new_entity.name.data);
        new_entity.name = cached_name;

        return new_entity;
    }

    LogSectionScope(*Log_Entities);

    DestroyWorld(dest);

    for :AllEntities entity : src {
        CopyEntityOver(dest, src, entity);
    }

    // Attach all entities to their parent correctly
    for :AllEntities entity : dest {
        if entity.parent != Null_Entity_GUID {
            parent_id := entity.parent;
            entity.parent = Null_Entity_GUID;

            parent, err := GetEntity(dest, *parent_id);
            if !parent {
                LogError("Entity does not exist %", parent_id);
                continue;
            }

            AttachEntity(dest, entity, parent);
        }
    }
}

// for_expansion
AllEntities :: (world : *World, body : Code, flags : For_Flags) #expand {
    `it : *Entity;
    `it_index : EntityIndex;
    should_break := false;

    #insert -> string {
        builder : StringBuilder;

        for i : 1..Entity_Types.count - 1 {
            if i != 1 {
                Appendln(*builder, "\nif should_break {\n    return;\n}\n");
            }

            Appendln(*builder, "for * entity, index : world.%_storage {", Entity_Types[i]);
            Appendln(*builder, "    it = entity;");
            Appendln(*builder, "    it_index = entity.index;");
            Appendln(*builder, "    #insert(break={should_break=true;break;}) body;");
            Appendln(*builder, "}");
        }

        return StringBuilderBuild(*builder);
    }
}

AllVisibleEntities :: (world : *World, body : Code, flags : For_Flags) #expand {
    for :AllEntities `it, `it_index : world {
        if it.flags & .Hidden {
            continue;
        }

        #insert body;
    }
}

LoadWorldFromDirectory :: (world : *World, directory : string) {
    LogSectionScope(*Log_Entities);

    start_time := Basic.current_time_monotonic();
    loaded_entities := 0;

    DestroyWorld(world);

    world.loaded_from_directory = StringClone(directory);

    DeferNextAssetLoadsForAllCaches();

    defer {
        end_time := Basic.current_time_monotonic();
        total_time_ms := Basic.to_float64_seconds(end_time - start_time) * 1000;

        asset_start_time := Basic.current_time_monotonic();

        LoadPendingAssets();

        asset_end_time := Basic.current_time_monotonic();
        asset_total_time_ms := Basic.to_float64_seconds(asset_end_time - asset_start_time) * 1000;

        LogContentMessage("Loaded world from directory '%' (% entities) in % ms",
            directory, loaded_entities, total_time_ms);
        LogMessage("Loaded assets for scene in % ms", asset_total_time_ms);
    }

    files : []string;

    // No logging please!
    {
        LoggerScope(null, IgnoreLogger);
        files = file_list(directory ,, Temp);
    }

    found_world_file := false;
    for files {
        if path_extension(it) == "world" {
            if found_world_file {
                LogContentError("Found multiple .world files in directory '%'", directory);
                continue;
            }

            found_world_file = true;

            file_contents, file_ok := read_entire_file(it, log_errors=false);
            if !file_ok {
                LogContentError("Could not read file '%'", it);
                continue;
            }

            defer Free(file_contents.data);

            result := DeserializeAny(file_contents, world);
            if !result.ok {
                LogContentError("There were errors when deserializing world settings:\n%:%:%: %",
                    it, result.line_index + 1, result.byte_index + 1, result.error_msg);
            }
        } else if path_extension(it) == "entity" {
            basename := path_basename(it);
            guid_str := string.{0, basename.data};
            for i : 0..basename.count - 1 {
                if basename[i] == #char "_" {
                    break;
                }

                guid_str.count += 1;
            }

            type_str := StringAdvance(basename, guid_str.count + 1);

            guid : EntityGUID;
            guid.high, ok:, guid_str = ParseFixedWidthHexInteger(guid_str, 16, u64);
            if !ok {
                LogContentError("Invalid entity filename '%' (invalid GUID)", it);
                continue;
            }

            guid.low, ok, guid_str = ParseFixedWidthHexInteger(guid_str, 16, u64);
            if !ok || guid_str.count != 0 {
                LogContentError("Invalid entity filename '%' (invalid GUID)", it);
                continue;
            }

            type := void;
            type_id := EntityTypeId.Invalid;
            for i : 1..Entity_Types.count - 1 {
                info_struct := cast(*Type_Info_Struct) Entity_Types[i];
                if info_struct.name == type_str {
                    type = Entity_Types[i];
                    type_id = cast(EntityTypeId) i;
                    break;
                }
            }

            if type == void {
                LogContentError("Invalid entity filename '%' (invalid type name '%')", it, type_str);
                continue;
            }

            file_contents, file_ok := read_entire_file(it, log_errors=false);
            if !file_ok {
                LogContentError("Could not read file '%'", it);
                continue;
            }

            defer Free(file_contents.data);

            entity := SpawnEntity(world, type_id, guid=guid);

            result := DeserializeEntity(file_contents, entity);
            if !result.ok {
                LogContentError("There were errors when deserializing entity:\n%:%:%: %",
                    it, result.line_index + 1, result.byte_index + 1, result.error_msg);
            }

            UpdateWorldTransform(world, entity);

            if entity.name {
                name := entity.name;
                entity.name = "";
                SetEntityName(world, entity, name);
                Free(name.data);
            }

            loaded_entities += 1;
        }
    }

    // Attach all entities to their parent correctly
    for :AllEntities entity : world {
        if entity.parent != Null_Entity_GUID {
            parent_id := entity.parent;
            entity.parent = Null_Entity_GUID;

            parent, err := GetEntity(world, *parent_id);
            if !parent {
                LogError("Entity does not exist %", parent_id);
                continue;
            }

            AttachEntity(world, entity, parent);
        }
    }
}

SaveWorldToDirectory :: (world : *World, output_directory : string) {
    LogSectionScope(*Log_Entities);

    start_time := Basic.current_time_monotonic();

    // No logging please!
    {
        LoggerScope(null, IgnoreLogger);

        files := file_list(output_directory ,, Temp);
        for files {
            if path_extension(it) == "entity" || path_extension(it) == "world" {
                file_delete(it);
            }
        }
    }

    make_directory_if_it_does_not_exist(output_directory, recursive=true);

    saved_entities := 0;

    for :AllEntities world {
        serializer : Serializer;
        serializer.builder.allocator = Temp;

        SerializeEntity(*serializer, it);

        filename := TPrint("%/%_%.entity", output_directory, it.guid, GetEntityType(it.index));
        ok := write_entire_file(filename, *serializer.builder);
        if !ok {
            LogContentError("Could not save entity to file '%'", filename);
        } else {
            saved_entities += 1;
        }
    }

    old_dir := world.loaded_from_directory; // Just in case output_directory.data == world.loaded_from_directory.data
    world.loaded_from_directory = StringClone(output_directory);
    Free(old_dir.data);

    serializer : Serializer;
    serializer.builder.allocator = Temp;

    SerializeAny(*serializer, world);

    world_filename := TPrint("%/%.world", output_directory, path_basename(output_directory));

    ok := write_entire_file(world_filename, *serializer.builder);
    if !ok {
        LogContentError("Could not save world to file '%'", world_filename);
    }

    end_time := Basic.current_time_monotonic();
    total_time_ms := Basic.to_float64_seconds(end_time - start_time) * 1000;

    LogContentMessage("Saved world to directory '%' (% entities) in % ms",
        output_directory, saved_entities, total_time_ms);
}
