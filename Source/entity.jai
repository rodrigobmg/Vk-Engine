// WARNING: if this file is renamed or moved, or if the Entity struct is moved to
// another file, Build/entity.jai must be updated accordingly

Log_Entities :: Log_Section.{name="Entities"};

Entity :: struct {
    #as guid : EntityGUID; @Serialize(1) @HideInInspector
    index : EntityIndex;
    flags : EntityFlags; @Serialize(7)

    name : string; @Serialize(2) @HideInInspector

    local_position : Vec3f; @Serialize(3)
    local_rotation : Quatf; @Serialize(4)
    local_scale : Vec3f = .{1,1,1}; @Serialize(5)

    world_transform : Mat4f;
    inv_world_transform : Mat4f;
    parent : EntityGUID; @Serialize(6)
    children : [..]EntityIndex;
}

EmptyEntity :: struct {
    #as using _ : Entity; @Serialize(1) @InspectorNoTree

    GetEditorIcon :: (world : *World, using entity : *EmptyEntity) -> *Asset(Texture2D) {
        return LoadAssetPermanent(Texture2D, "Editor/Icons/Default.png");
    }
} @Entity

EntityFlags :: enum_flags {
    Hidden;
}

// Generated by the metaprogram
#placeholder Entity_Types;
#placeholder EntityTypeId;

// Index into Entity_Types array, index Invalid maps to void

#insert -> string {
    builder : StringBuilder;

    Appendln(*builder, "EntityTypeId :: enum u8 {");
    Appendln(*builder, "    Invalid :: 0;");

    for i : 1..Entity_Types.count - 1 {
        Appendln(*builder, "    % :: %;", Entity_Types[i], i);
    }

    Appendln(*builder, "}");

    return StringBuilderBuild(*builder);
};

#assert Entity_Types.count <= 256; // The type id must fit in a u8

Detect_Entity_Recursive_Attachment :: true;

Entities_Per_Page :: 20;

EntityStorage :: #bake_arguments PagedArray(Page_Size=Entities_Per_Page);

// EntityIndex is guaranteed to be unique for all currently existing entities
// It is a compressed version of PagedArraySlotInfo with an additional id
// for the entity type.
// Layout: [8 bit type_id][24 bit version][24 bit page_index][8 bit slot_index]

Entity_Index_Type_Id_Bits   :: 8;
Entity_Index_Type_Id_Offset :: Entity_Index_Version_Offset + Entity_Index_Version_Bits;
Entity_Index_Type_Id_Mask   :: 0xff << Entity_Index_Type_Id_Offset;

Entity_Index_Version_Bits   :: 24;
Entity_Index_Version_Offset :: Entity_Index_Page_Index_Offset + Entity_Index_Page_Index_Bits;
Entity_Index_Version_Mask   :: 0xffffff << Entity_Index_Version_Offset;

Entity_Index_Page_Index_Bits   :: 24;
Entity_Index_Page_Index_Offset :: Entity_Index_Slot_Index_Offset + Entity_Index_Slot_Index_Bits;
Entity_Index_Page_Index_Mask   :: 0xffffff << Entity_Index_Page_Index_Offset;

Entity_Index_Slot_Index_Bits   :: 8;
Entity_Index_Slot_Index_Offset :: 0;
Entity_Index_Slot_Index_Mask   :: 0xff << Entity_Index_Slot_Index_Offset;

#assert Entity_Index_Type_Id_Offset + Entity_Index_Type_Id_Bits <= size_of(EntityIndex) * 8;

EntityIndex :: #type, distinct u64;

Null_Entity_GUID :: EntityGUID.{};

EntityGUID :: struct {
    low, high : u64;
}

operator == :: inline (a : EntityGUID, b : EntityGUID) -> bool {
    return a.low == b.low && a.high == b.high;
}

HashEntityGUID :: inline (guid : EntityGUID) -> u64 {
    #import "Hash";

    h := fnv1a_hash(guid.low);
    h = fnv1a_hash(guid.high, h);

    return h;
}

g_entity_guid_random_state_low : Random_State;
g_entity_guid_random_state_high : Random_State;

GenerateEntityGUID :: () -> EntityGUID {
    #import "Random";

    if g_entity_guid_random_state_low.low == 0 && g_entity_guid_random_state_low.high == 0 {
        seed := Basic.current_time_monotonic();
        random_seed(*g_entity_guid_random_state_low, Random_State.{xx seed.low, xx seed.high});
        random_seed(*g_entity_guid_random_state_high, Random_State.{xx seed.high, xx seed.low});
    }

    return .{
        random_get(*g_entity_guid_random_state_low),
        random_get(*g_entity_guid_random_state_high),
    };
}

CompareEntityIndex :: inline (a : EntityIndex, b : EntityIndex) -> int {
    a &= ~Entity_Index_Version_Mask;
    b &= ~Entity_Index_Version_Mask;

    if a < b {
        return -1;
    }
    if a > b {
        return 1;
    }
    return 0;
}

IsInEntityTypesArray :: (type : Type) -> bool {
    for i : 1..Entity_Types.count - 1 {
        if Entity_Types[i] == type {
            return true;
        }
    }

    return false;
}

GetEntityTypeId :: (type : Type) -> EntityTypeId {
    for Entity_Types {
        if it == type {
            return cast(EntityTypeId, it_index);
        }
    }

    return .Invalid;
}

GetEntityTypeId :: inline (index : EntityIndex) -> EntityTypeId {
    type_id := cast(u8, index >> Entity_Index_Type_Id_Offset);

    if type_id >= Entity_Types.count {
        return .Invalid;
    }

    return cast(EntityTypeId, type_id);
}

GetEntityType :: inline (index : EntityIndex) -> Type {
    return GetEntityType(GetEntityTypeId(index));
}

GetEntityType :: inline (type_id : EntityTypeId) -> Type {
    return Entity_Types[type_id];
}

MakeEntityIndex :: inline (type_id : EntityTypeId, using slot_info : PagedArraySlotInfo) -> EntityIndex {
    Assert(version == (version & 0xffffff), "Version number is too big");
    Assert(page_index == (page_index & 0xffffff), "Page index is too big");
    Assert(slot_index == (slot_index & 0xff), "Slot index is too big");

    result :=
          (cast(u64, type_id)    << Entity_Index_Type_Id_Offset)
        | (cast(u64, version)    << Entity_Index_Version_Offset)
        | (cast(u64, page_index) << Entity_Index_Page_Index_Offset)
        | (cast(u64, slot_index) << Entity_Index_Slot_Index_Offset);

    return cast(EntityIndex, result);
}

GetSlotInfo :: inline (index : EntityIndex) -> PagedArraySlotInfo {
    return .{
        cast(u32, (index >> Entity_Index_Version_Offset)    & 0xffffff),
        cast(s32, (index >> Entity_Index_Page_Index_Offset) & 0xffffff),
        cast(s32, (index >> Entity_Index_Slot_Index_Offset) & 0xff)
    };
}

EntityIsInHierarchy :: (world : *World, entity : *Entity, of : *Entity) -> bool {
    if !entity {
        return false;
    }

    if entity == of {
        return true;
    }

    if of.children.count == 0 {
        return false;
    }

    for of.children {
        child := GetEntity(world, it);
        if entity == child {
            return true;
        }
    }

    for of.children {
        child := GetEntity(world, it);

        if EntityIsInHierarchy(world, entity, child) {
            return true;
        }
    }

    return false;
}

TryDowncast :: inline (entity : *Entity, $T : Type) -> *T
#modify { return IsInEntityTypesArray(T); } {
    if !entity {
        return null;
    }

    if GetEntityTypeId(entity.index) != #run GetEntityTypeId(T) {
        return null;
    }

    return cast(*T, entity);
}

Downcast :: inline (entity : *Entity, $T : Type) -> *T
#modify { return IsInEntityTypesArray(T); } {
    if !entity {
        return null;
    }

    if GetEntityTypeId(entity.index) != #run GetEntityTypeId(T) {
        LogError(
            "Entity downcast failed: type % does not match entity type id %",
            T, GetEntityTypeId(entity.index)
        );

        return null;
    }

    return cast(*T, entity);
}

SetEntityName :: inline (using world : *World, entity : *Entity, new_name : string) -> set_same_name : bool {
    LogSectionScope(*Log_Entities);

    SeparatePostfixNumber :: (str : string) -> postfix : int, name_without_postfix : string {
        dot_index := find_index_from_right(str, #char ".");
        if dot_index == -1 || dot_index == str.count - 1 {
            return -1, str;
        }

        for i : dot_index + 1..str.count - 1 {
            if !Basic.is_digit(str[i]) {
                return -1, str;
            }
        }

        str_without_postfix := str;
        str_without_postfix.count = dot_index;
        postfix_str := StringAdvance(str, dot_index + 1);
        postfix := Basic.string_to_int(postfix_str);

        return postfix, str_without_postfix;
    }

    if entity.name {
        HashMapRemove(*entities_by_name, entity.name);
        Free(entity.name.data ,, entities_by_name.allocator);
        entity.name = "";
    }

    if !new_name {
        return true;
    }

    number_postfix := -1;

    // Try to prevent .0.0.0.0 postfix by parsing the name and trimming the .NUMBER at the end
    first_number_postfix, name_without_postfix := SeparatePostfixNumber(new_name);
    while true {
        if number_postfix == -1 {
            entity.name = StringClone(new_name ,, entities_by_name.allocator);
        } else {
            entity.name = SPrint("%.%", name_without_postfix, number_postfix ,, entities_by_name.allocator);
        }

        entity_ptr, already_exists := HashMapInsert(*entities_by_name, entity.name);
        if already_exists {
            if number_postfix == -1 {
                number_postfix = first_number_postfix + 1;
            } else {
                number_postfix += 1;
            }

            // LogError("Entity with name '%' already exists", entity.name);

            Free(entity.name.data ,, entities_by_name.allocator);
            entity.name = "";
        } else {
            entity_ptr.* = entity;
            break;
        }
    }

    return number_postfix == -1;
}

GetEntityError :: enum {
    Ok;
    NullEntity;
    InvalidEntityIndex;
    EntityKilled;
    EntityKilledOrNeverSpawned;
    DowncastFailed;
}

GetEntityByName :: inline (using world : *World, name : string) -> *Entity {
    return HashMapGet(*entities_by_name, name, fallback = null);
}

GetEntityByName :: inline (using world : *World, name : string, $T : Type) -> *T, GetEntityError
#modify { return IsInEntityTypesArray(T); } {
    entity := HashMapGet(*entities_by_name, name, fallback = null);
    if !entity {
        return null, .NullEntity;
    }

    typed_entity := TryDowncast(entity, T);
    if !typed_entity {
        return null, .DowncastFailed;
    }

    return typed_entity, .Ok;
}

GetEntity :: (using world : *World, guid : EntityGUID, $T : Type) -> *T, GetEntityError
#modify { return IsInEntityTypesArray(T); } {
    entity, err := GetEntity(world, guid);
    if !entity {
        return null, err;
    }

    typed_entity := TryDowncast(entity, T);
    if !typed_entity {
        return null, .DowncastFailed;
    }

    return typed_entity, .Ok;
}

GetEntity :: (using world : *World, guid : EntityGUID) -> *Entity, GetEntityError {
    if guid == Null_Entity_GUID {
        return null, .NullEntity;
    }

    entity, err := HashMapGet(*entities_by_guid, guid);
    if !entity {
        return null, .EntityKilledOrNeverSpawned;
    }

    return entity, .Ok;
}

GetEntity :: (using world : *World, index : EntityIndex, $T : Type) -> *T, GetEntityError
#modify { return IsInEntityTypesArray(T); } {
    entity, err := GetEntity(world, index);
    if !entity {
        return null, err;
    }

    typed_entity := TryDowncast(entity, T);
    if !typed_entity {
        return null, .DowncastFailed;
    }

    return typed_entity, .Ok;
}

GetEntity :: (using world : *World, index : EntityIndex) -> *Entity, GetEntityError {
    LogSectionScope(*Log_Entities);

    if index == 0 {
        return null, .NullEntity;
    }

    type_id := GetEntityTypeId(index);
    slot_info := GetSlotInfo(index);

    #insert -> string {
        builder : StringBuilder;

        Appendln(*builder, "if #complete type_id == {");
        Appendln(*builder, "case .Invalid; LogError(\"Requesting entity with invalid type id(\%)\", type_id); return null, .InvalidEntityIndex;");

        for i : 1..Entity_Types.count - 1
        {
            it := Entity_Types[i];
            Appendln(*builder, "case .%;", it);
            Appendln(*builder, "    valid, corrupt, not_occupied, version_mismatch := PagedArrayIsSlotValid(*%_storage, slot_info);", it);
            Appendln(*builder, "    if not_occupied || version_mismatch {");
            Appendln(*builder, "        return null, .EntityKilled;");
            Appendln(*builder, "    }");
            Appendln(*builder, "    if !valid {");
            Appendln(*builder, "        return null, .InvalidEntityIndex;");
            Appendln(*builder, "    }");
            Appendln(*builder, "    return PagedArrayGetItem(*%_storage, slot_info), .Ok;", it);
        }

        Appendln(*builder, "}");

        return StringBuilderBuild(*builder);
    }

    return null, .InvalidEntityIndex;
}

CallEntityCallback :: inline (world : *World, entity : *$T, $Callback : string)
#modify { return T == Entity || IsInEntityTypesArray(T); } {
    #if T == Entity {
        #insert -> string {
            builder : StringBuilder;

            Appendln(*builder, "if GetEntityTypeId(entity.index) == {");
            for i : 1..Entity_Types.count - 1 {
                type := Entity_Types[i];
                Appendln(*builder, "case .%1; #if #exists(%1.%2) { %1.%2(world, xx entity); }", type, Callback);
            }
            Appendln(*builder, "}");

            return StringBuilderBuild(*builder);
        }
    } else {
        #insert #run TPrint("#if #exists(T.%1) { T.%1(world, entity); }", Callback);
    }
}

AttachEntity :: (using world : *World, entity : *Entity, to : *Entity, keep_same_world_transform := false) {
    LogSectionScope(*Log_Entities);

    Assert(entity != null);
    Assert(to != null);

    if entity == to {
        LogError("Trying to attach entity to itself");
        return;
    }

    // Detect entity attaching itself to one of its descendants
    #if Detect_Entity_Recursive_Attachment {
        if EntityIsInHierarchy(world, to, entity) {
            LogError("Trying to recursively attach entity to one of its descendants");
            return;
        }
    }

    if entity.parent != Null_Entity_GUID {
        DetachEntity(world, entity);
    }

    ArrayPush(*to.children, entity.index);

    entity.parent = to.guid;

    if keep_same_world_transform {
        local_transform := Inverse(to.world_transform) * entity.world_transform;

        entity.local_position = TranslationVector(local_transform);
        entity.local_rotation = QuatfFromMatrix(local_transform);

        // Extracting scale from a matrix does not give good results, walk the hierarchy instead
        // @Todo: orientations may not be the same between a parent and its child, so X axis scale of parent
        // may not be X axis scale of child. Use GetScaleOnAxis like we do in EntityGizmo procedure.
        parent_for_scale := to;
        while parent_for_scale {
            entity.local_scale = InvScale(entity.local_scale, parent_for_scale.local_scale);
            parent_for_scale = GetEntity(world, parent_for_scale.parent);
        }
    }

    UpdateWorldTransform(world, entity);
    CallEntityCallback(world, entity, "OnAttach");

    LogMessage("Attached entity % to %", entity.guid, to.guid, flags=.VERBOSE_ONLY);
}

DetachEntity :: (using world : *World, entity : *Entity, keep_same_world_transform := false) {
    LogSectionScope(*Log_Entities);

    if entity.parent == Null_Entity_GUID {
        return;
    }

    CallEntityCallback(world, entity, "OnDetach");

    parent := GetEntity(world, *entity.parent);
    Assert(parent != null);

    child_index := ArrayFindFirst(parent.children, entity.index);
    Assert(child_index != -1);

    ArrayRemove(*parent.children, child_index);

    entity.parent = .{};

    if keep_same_world_transform {
        entity.local_position = TranslationVector(entity.world_transform);
        entity.local_rotation = QuatfFromMatrix(entity.world_transform);

        // Extracting scale from a matrix does not give good results, walk the hierarchy instead
        parent_for_scale := parent;
        while parent_for_scale {
            entity.local_scale = Scale(entity.local_scale, parent_for_scale.local_scale);
            parent_for_scale = GetEntity(world, parent_for_scale.parent);
        }
    }

    UpdateWorldTransform(world, entity);

    LogMessage("Detached entity % from %", entity.guid, parent.guid, flags=.VERBOSE_ONLY);
}

UpdateWorldTransform :: (world : *World, entity : *Entity, update_children := true) {
    parent := ifx entity.parent != Null_Entity_GUID then GetEntity(world, *entity.parent);

    local_transform := Mat4fTransformSRT(entity.local_position, entity.local_rotation, entity.local_scale);

    if parent {
        entity.world_transform = parent.world_transform * local_transform;

        // Remove skewing from world transform
        Q, S := PolarDecompose(entity.world_transform);
        S2 := Mat4f.{r0c0=S.r0c0, r1c1=S.r1c1, r2c2=S.r2c2, r3c3=1};

        T := Mat4fTranslate(TranslationVector(entity.world_transform));

        entity.world_transform = T * ToMat4f(Q) * S2;
        entity.inv_world_transform = Inverse(entity.world_transform);
    } else {
        entity.world_transform = local_transform;
        entity.inv_world_transform = Inverse(local_transform);
    }

    if update_children {
        for entity.children {
            child := GetEntity(world, it);
            Assert(child != null);

            UpdateWorldTransform(world, child);
        }
    }
}

SpawnEntity :: (using world : *World, $T : Type, name := "", guid := Null_Entity_GUID) -> *T
#modify { return IsInEntityTypesArray(T); } {
    entity := SpawnEntity(world, #run GetEntityTypeId(T), name, guid);

    return cast(*T, entity);
}

SpawnEntity :: (using world : *World, type : EntityTypeId, name := "", guid := Null_Entity_GUID) -> *Entity {
    LogSectionScope(*Log_Entities);

    if type == .Invalid {
        return null;
    }

    entity : *Entity;
    slot_info : PagedArraySlotInfo;
    #insert -> string {
        builder : StringBuilder;

        Appendln(*builder, "if type == {");

        for i : 1..Entity_Types.count - 1 {
            Appendln(*builder, "case .%;", Entity_Types[i]);
            Appendln(*builder, "    entity, slot_info = PagedArrayFindSlot(*%_storage);", Entity_Types[i]);
        }

        Appendln(*builder, "}");

        return StringBuilderBuild(*builder);
    }

    entity.index = MakeEntityIndex(type, slot_info);

    if guid.low || guid.high {
        entity.guid = guid;
    } else {
        entity.guid = GenerateEntityGUID();
    }

    entity_ptr, already_exists := HashMapInsert(*entities_by_guid, entity.guid);
    if already_exists {
        LogError("Entity with GUID % already exists", entity.guid);
    } else {
        entity_ptr.* = entity;
    }

    if name {
        SetEntityName(world, entity, name);
    }

    CallEntityCallback(world, entity, "OnSpawn");

    if name {
        LogMessage("Spawned entity % (%, %)",
            name, type, entity.guid,
            flags=.VERBOSE_ONLY
        );
    } else {
        LogMessage("Spawned entity (%, %)",
            type, entity.guid,
            flags=.VERBOSE_ONLY
        );
    }

    return entity;
}

SpawnAndDeserializeEntity :: (using world : *World, text : string, type_id : EntityTypeId, name := "", guid := Null_Entity_GUID) -> *Entity {
    entity := SpawnEntity(world, type_id, guid=guid, name=name);
    cached_name := entity.name;

    result := DeserializeEntity(text, entity);
    if !result.ok {
        LogContentError("There were errors when deserializing entity:\n%_%:%:%: %",
            type_id, guid, result.line_index + 1, result.byte_index + 1, result.error_msg);
    }

    UpdateWorldTransform(world, entity);

    if cached_name {
        Assert(cached_name == entity.name);
        Free(entity.name.data);
        entity.name = cached_name;
    } else if entity.name {
        name := entity.name;
        entity.name = "";
        SetEntityName(world, entity, name);
        Free(name.data);
    }

    if entity.parent != Null_Entity_GUID {
        parent, err := GetEntity(world, *entity.parent);
        if parent {
            // AttachEntity detaches from previous parent, so clear entity.parent beforehand
            entity.parent = .{};
            AttachEntity(world, entity, parent);
        } else {
            LogError("In SpawnAndDeserializeEntity, when trying to attach entity, GetEntity failed for parent % (%)", entity.parent, err);
            entity.parent = .{};
        }
    }

    return entity;
}

SerializeEntity :: inline (serializer : *Serializer, entity : *Entity) {
    any : Any = ---;
    any.type = cast(*Type_Info, GetEntityType(GetEntityTypeId(entity.index)));
    any.value_pointer = entity;

    SerializeAny(serializer, any);
}

DeserializeEntity :: inline (text : string, entity : *Entity) -> DeserializeResult {
    any : Any = ---;
    any.type = cast(*Type_Info, GetEntityType(GetEntityTypeId(entity.index)));
    any.value_pointer = entity;

    cached_guid := entity.guid;
    cached_index := entity.index;
    result := DeserializeAny(text, any);
    entity.guid = cached_guid;
    entity.index = cached_index;

    return result;
}

KillEntity :: (using world : *World, guid : EntityGUID) {
    LogSectionScope(*Log_Entities);

    entity := GetEntity(world, guid);
    if entity == null {
        LogError("Killing entity with GUID % but it does not exist", guid);
        return;
    }

    for entities_killed_this_frame {
        if it == entity.index {
            return;
        }
    }

    ArrayPush(*entities_killed_this_frame, entity.index);
}

KillEntity :: (using world : *World, index : EntityIndex) {
    LogSectionScope(*Log_Entities);

    if GetEntity(world, index) == null {
        LogError("Killing entity with index % but it does not exist", index);
        return;
    }

    for entities_killed_this_frame {
        if it == index {
            return;
        }
    }

    ArrayPush(*entities_killed_this_frame, index);
}

DestroyKilledEntities :: (using world : *World) {
    DestroyEntity :: (using world : *World, index : EntityIndex) {
        entity := GetEntity(world, index);
        Assert(entity != null);

        type_id := GetEntityTypeId(index);

        if entity.parent != Null_Entity_GUID {
            DetachEntity(world, entity, keep_same_world_transform=true);
        }

        while entity.children.count > 0 {
            child := GetEntity(world, entity.children[0]);
            if child {
                DetachEntity(world, child, keep_same_world_transform=true);
            }
        }

        CallEntityCallback(world, entity, "OnDespawn");

        ArrayFree(*entity.children);

        if entity.name {
            Free(entity.name.data ,, entities_by_name.allocator);
            HashMapRemove(*entities_by_name, entity.name);
        }

        HashMapRemove(*entities_by_guid, entity.guid);

        slot_info := GetSlotInfo(entity.index);

        #insert -> string {
            builder : StringBuilder;

            Appendln(*builder, "if type_id == {");

            for i : 1..Entity_Types.count - 1 {
                Appendln(*builder, "case .%;", Entity_Types[i]);
                Appendln(*builder, "    UnreferenceAllAssets(cast(*%, entity));", Entity_Types[i]);
                Appendln(*builder, "    PagedArrayFreeSlot(*%_storage, slot_info);", Entity_Types[i]);
            }

            Appendln(*builder, "}");

            return StringBuilderBuild(*builder);
        }
    }

    LogSectionScope(*Log_Entities);

    // Sorted by memory proximity and type
    QuickSort(entities_killed_this_frame, CompareEntityIndex);

    for index : entities_killed_this_frame {
        DestroyEntity(world, index);
    }

    ArrayClear(*entities_killed_this_frame);
}
