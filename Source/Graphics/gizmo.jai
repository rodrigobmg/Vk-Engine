// @Todo: ensure we don't use more samples than what is allowed on the machine
// @Todo: do not do multisampling and create resolve texture when num samples == 1
Gizmo_Texture_Num_Samples :: 8;

GizmoBindingSet :: struct {
    viewpoint : GfxBindingUniformBuffer; @Binding(0) @VertexStage
    instances : GfxBindingStorageBuffer; @Binding(1) @VertexStage @AllowNull
} @BindingSet

g_gizmo_pipeline : GfxGraphicsPipeline;

CreateGizmoPipeline :: () {
    desc : GfxGraphicsPipelineDesc;
    desc.vertex_shader = GetVertexShader("gizmo");
    desc.fragment_shader = GetFragmentShader("gizmo");
    desc.rasterizer_state = .{cull_face=.None, num_samples=Gizmo_Texture_Num_Samples};
    desc.blend_states[0] = .{enabled=true};
    desc.depth_state = .{test_enabled=true, write_enabled=true, compare_op=Depth_Compare_Op};

    AddColorAttachment(*desc, .RGBA8UNorm);
    desc.depth_format = .Depth32Float;

    desc.vertex_input = MakeVertexInputDesc(StaticVertex, 0);

    desc.layout.binding_sets = .[
        g_binding_set_layouts.FrameBindingSet,
        g_binding_set_layouts.GizmoBindingSet,
    ];

    ok := CreateGfxGraphicsPipeline(*g_gizmo_pipeline, "Gizmo", desc);
    Assert(ok, "Could not create gizmo pipeline");
}

CreateGizmoTextures :: (ctx : *GizmoContext) {
    if !IsNull(*ctx.color_texture) {
        DestroyGfxTexture(*ctx.color_texture);
    }
    if !IsNull(*ctx.color_resolve) {
        DestroyGfxTexture(*ctx.color_resolve);
    }
    if !IsNull(*ctx.depth_texture) {
        DestroyGfxTexture(*ctx.depth_texture);
    }

    w, h := GetWindowPixelSize(g_window);

    desc : GfxTextureDesc;
    desc.type = .Texture2D;
    desc.pixel_format = .RGBA8UNorm;
    desc.width = xx w;
    desc.height = xx h;
    desc.usage = .ColorAttachment | .Sampled;

    ctx.color_resolve = CreateGfxTexture("Gizmo Color Resolve", desc);
    Assert(!IsNull(*ctx.color_resolve), "Could not create gizmo color texture");

    desc.num_samples = Gizmo_Texture_Num_Samples;

    ctx.color_texture = CreateGfxTexture("Gizmo Color", desc);
    Assert(!IsNull(*ctx.color_texture), "Could not create gizmo color texture");

    desc.pixel_format = .Depth32Float;
    desc.usage = .DepthStencilAttachment;

    ctx.depth_texture = CreateGfxTexture("Gizmo Depth", desc);
    Assert(!IsNull(*ctx.depth_texture), "Could not create gizmo depth texture");
}

GizmoPass :: (using ctx : *FrameRenderContext, gizmo_ctx : *GizmoContext) {
    Assert(gizmo_ctx != null);

    if IsNull(*g_gizmo_pipeline) {
        CreateGizmoPipeline();
    }

    AddTextureBarrier(cmd_buffer, .Undefined, .ColorAttachment, *gizmo_ctx.color_texture);
    AddTextureBarrier(cmd_buffer, .Undefined, .ColorAttachment, *gizmo_ctx.color_resolve);
    AddTextureBarrier(cmd_buffer, .Undefined, .DepthStencilAttachment, *gizmo_ctx.depth_texture);

    w, h := GetWindowPixelSize(g_window);

    viewpoint_offset, viewpoint_size := AllocAndPackUniformFrameData(MakeViewpoint(gizmo_ctx.camera));
    instances_offset, instances_size := AllocAndPackStorageFrameData(gizmo_ctx.widgets);

    bindings := GizmoBindingSet.{
        viewpoint=.{buffer=FrameDataBuffer(), offset=xx viewpoint_offset, size=xx viewpoint_size},
        instances=.{buffer=FrameDataBuffer(), offset=xx instances_offset, size=xx instances_size},
    };

    binding_set := CreateGfxBindingSet(GlobalBindingSetAllocator(), bindings);

    pass_desc : GfxRenderPassDesc;
    AddColorAttachment(*pass_desc, *gizmo_ctx.color_texture, resolve_texture=*gizmo_ctx.color_resolve);
    AddDepthAttachment(*pass_desc, *gizmo_ctx.depth_texture);
    ClearColor(*pass_desc, 0, Vec4f.{0,0,0,0});
    ClearDepth(*pass_desc, Depth_Clear);

    pass := BeginGfxRenderPass(cmd_buffer, "Gizmo", pass_desc);
    {
        BindGraphicsPipeline(*pass, *g_gizmo_pipeline);
        SetViewport(*pass, .{width=xx w, height=xx h});
        SetScissor(*pass, .{w=xx w, h=xx h});

        BindGraphicsBindingSet(*pass, 1, *binding_set);

        prev_mesh : *Asset(StaticMesh);
        for gizmo_ctx.widgets {
            mesh := gizmo_ctx.meshes.all[it.mesh_id];
            if mesh != prev_mesh {
                BindVertexBuffer(*pass, 0, *mesh.vertex_buffer);
                BindIndexBuffer(*pass, .UInt32, *mesh.index_buffer);
                prev_mesh = mesh;
            }

            DrawIndexed(*pass, index_count=mesh.index_count, instance_count=1, base_instance=xx it_index);
        }
    }
    EndGfxRenderPass(*pass);

    GizmoLinesPass(ctx, gizmo_ctx);

    AddTextureBarrier(cmd_buffer, .ColorAttachment, .ShaderReadOnly, *gizmo_ctx.color_resolve);
}

g_gizmo_lines_pipeline : GfxGraphicsPipeline;

CreateGizmoLinesPipeline :: () {
    desc : GfxGraphicsPipelineDesc;
    desc.vertex_shader = GetVertexShader("debug_line");
    desc.fragment_shader = GetFragmentShader("debug_line");
    desc.primitive_topology = .LineList;
    desc.rasterizer_state = .{cull_face=.None, num_samples=Gizmo_Texture_Num_Samples};

    desc.layout.binding_sets = .[
        g_binding_set_layouts.FrameBindingSet,
        g_binding_set_layouts.DebugLinesBindingSet,
    ];

    AddColorAttachment(*desc, .RGBA8UNorm);
    desc.depth_format = .Depth32Float;

    desc.blend_states[0] = .{enabled=true};
    desc.depth_state = .{test_enabled=true, write_enabled=true, compare_op=Depth_Compare_Op};

    ok := CreateGfxGraphicsPipeline(*g_gizmo_lines_pipeline, "Gizmo Lines", desc);
    Assert(ok, "Could not create gizmo lines pipeline");
}

GizmoLinesPass :: (using ctx : *FrameRenderContext, gizmo_ctx : *GizmoContext) {
    if IsNull(*g_gizmo_lines_pipeline) {
        CreateGizmoLinesPipeline();
    }

    defer ArrayClear(*gizmo_ctx.lines_to_draw);

    if gizmo_ctx.lines_to_draw.count <= 0 {
        return;
    }

    w, h := GetWindowPixelSize(g_window);

    viewpoint := MakeViewpoint(gizmo_ctx.camera);
    viewpoint_offset, viewpoint_size := AllocAndPackUniformFrameData(viewpoint);

    lines_offset, lines_size := AllocAndPackStorageFrameData(gizmo_ctx.lines_to_draw);

    bindings := DebugLinesBindingSet.{
        viewpoint=.{buffer=FrameDataBuffer(), offset=xx viewpoint_offset, size=xx viewpoint_size},
        lines=.{buffer=FrameDataBuffer(), offset=xx lines_offset, size=xx lines_size},
    };
    binding_set := CreateGfxBindingSet(GlobalBindingSetAllocator(), bindings);

    pass_desc : GfxRenderPassDesc;
    AddColorAttachment(*pass_desc, *gizmo_ctx.color_texture, resolve_texture=*gizmo_ctx.color_resolve);
    AddDepthAttachment(*pass_desc, *gizmo_ctx.depth_texture, store_op=.DontCare);

    pass := BeginGfxRenderPass(cmd_buffer, "Gizmo Lines", pass_desc);
    {
        BindGraphicsPipeline(*pass, *g_gizmo_lines_pipeline);
        SetViewport(*pass, .{width=xx w, height=xx h});
        SetScissor(*pass, .{w=xx w, h=xx h});

        BindGraphicsBindingSet(*pass, 1, *binding_set);

        Draw(*pass, vertex_count=2, instance_count=xx gizmo_ctx.lines_to_draw.count);
    }
    EndGfxRenderPass(*pass);
}
